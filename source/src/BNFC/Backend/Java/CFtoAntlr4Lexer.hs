{-
    BNF Converter: Java Antlr4 Lexer generator
    Copyright (C) 2015  Author:  Gabriele Paganelli

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-}

{-
   **************************************************************
    BNF Converter Module

    Description   : This module generates the Antlr4 input file.
                    Based on CFtoJLex15.hs

    Author        : Gabriele Paganelli (gapag@distruzione.org)

    License       : GPL (GNU General Public License)

    Created       : 15 Oct, 2015

    Modified      :


   **************************************************************
-}

module BNFC.Backend.Java.CFtoAntlr4Lexer ( cf2AntlrLex ) where

import Text.PrettyPrint
import BNFC.CF
import BNFC.Backend.Java.RegToAntlrLexer
import BNFC.Backend.Java.Utils
import BNFC.Backend.Common.NamedVariables
import BNFC.PrettyPrint

data ANTLRLexerSpec = AL{
        preamble         :: Doc,
        javaCode         :: Doc,
        fragments        :: Doc,
        defaultMode      :: Doc,
        indentedMode     :: Doc,
        errorToken       :: Doc,
        builtinTypeModes :: Doc
    }

makeLexer :: ANTLRLexerSpec -> Doc
makeLexer AL{..} =
    vcat [
        preamble
        , javaCode
        , fragments
        , defaultMode
        , indentedMode
        , errorToken
        , builtinTypeModes
        ]


-- antlr@AL{..}

-- | Creates a lexer grammar.
-- Since antlr token identifiers must start with an uppercase symbol,
-- I prepend "Surrogate_id_SYMB_" to the identifier.
-- This introduces risks of clashes if somebody uses the same identifier for
-- user defined tokens. This is not handled.
-- returns the environment because the parser uses it.
cf2AntlrLex :: String -> CF -> (Doc, SymEnv)
cf2AntlrLex packageBase cf = (makeLexer al, env)
  where
    (al, mode) = if hasIndentation cf
                  then (alIndent, "INDENT" )
                  else (alNoIndent,"DEFAULT_MODE")
    alNoIndent = AL{
        preamble           = prelude packageBase
        , javaCode         = text ""
        , fragments        = vcat [
                               tokenFragments
                               , fragIdent
                               , whiteFragment
                             ]
        , defaultMode      = vcat $ whiteToken:defaultElements
        , indentedMode     = text ""
        , errorToken       = text "ErrorToken : . ;"
        , builtinTypeModes = vcat [ defString
                            , defChar
                            ]
        }
    alIndent   = alNoIndent{
        javaCode     = javaLexerPreamble,
        defaultMode  = indentationMode,
        indentedMode = vcat $  "mode INDENT;":(newlineToken:defaultElements)
    }
    uses cat = isUsedCat cf cat
    defaultElements = [ lexSymbols env
                      , lexComments (comments cf)
                      , userDefinedTokens cf
                      , defIdent
                      , tokenDouble
                      , tokenInteger
                      , initString
                      , initChar
                      ]
    conditionalDef defaultValue cat definition
                            = if uses cat
                                then definition
                                else defaultValue
    conditionalComplex = conditionalDef ("","")
    conditionalSimple = conditionalDef ""
    (fragIdent, defIdent)   =
        conditionalComplex catIdent identAntlrDefinition
    (initString, defString) =
        conditionalComplex catString $ stringAntlrDefinition mode
    (initChar, defChar)     =
        conditionalComplex catChar $ charAntlrDefinition mode
    tokenDouble             =
        conditionalSimple catDouble doubleAntlrDefinition
    tokenInteger            =
        conditionalSimple catInteger integerAntlrDefinition
    env                     =
                    makeSymEnv (cfgSymbols cf ++ reservedWords cf) (0 :: Int)
    makeSymEnv [] _         = []
    makeSymEnv (s:symbs) n  =
        (s, "Surrogate_id_SYMB_" ++ show n): makeSymEnv symbs (n+1)

    -- Take the longest


-- | File prelude
prelude ::  String -> Doc
prelude packageBase = vcat
    [ "// This Antlr4 file was machine-generated by the BNF converter"
    , "lexer grammar" <+> text name <> "Lexer;"
    ]
    where name = getLastInPackage packageBase

--For now all categories are included.
--Optimally only the ones that are used should be generated.
tokenFragments :: Doc
tokenFragments = vcat
    [ "// Predefined regular expressions in BNFC"
    , fragment "LETTER  : CAPITAL | SMALL"
    , fragment "CAPITAL : [A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]"
    , fragment "SMALL   : [a-z\\u00DF-\\u00F6\\u00F8-\\u00FF]"
    , fragment "DIGIT   : [0-9]"
    , "// Escapable sequences"
    , fragment "Escapable : ('\"' | '\\\\' | 'n' | 't' | 'r')"
    ]

fragment :: Doc -> Doc
fragment a = "fragment" <+> a <+> ";"

escapeChars :: String -> String
escapeChars = concatMap escapeChar

-- |
-- >>> lexSymbols [("foo","bar")]
-- bar : 'foo' ;
-- >>> lexSymbols [("\\","bar")]
-- bar : '\\' ;
-- >>> lexSymbols [("/","bar")]
-- bar : '/' ;
-- >>> lexSymbols [("~","bar")]
-- bar : '~' ;
lexSymbols :: SymEnv -> Doc
lexSymbols ss = vcat $  map transSym ss
  where
    transSym (s,r) = text r <>  " : '" <> text (escapeChars s) <> "' ;"

userDefinedTokens :: CF -> Doc
userDefinedTokens cf = vcat
    [ text (show name) <>" : " <> text (printRegJLex exp) <> ";"
    | (name, exp) <- tokenPragmas cf ]

type TypeToken    = Doc
type InitToken    = Doc
type AntlrModeDef = Doc
type Fragment     = Doc

identAntlrDefinition :: (Fragment, TypeToken)
identAntlrDefinition = (identFragment, identToken)

identFragment :: Fragment
identFragment = fragment "IDENTIFIER_FIRST : LETTER | '_'"

identToken :: TypeToken
identToken = "IDENT : IDENTIFIER_FIRST (IDENTIFIER_FIRST | DIGIT)*;"

whiteFragment :: Fragment
whiteFragment = fragment "White : (' ' | '\\r' | '\\t' )"

newlineToken :: TypeToken
newlineToken = vcat ["NEWLINE : '\\r'? '\\n'  -> skip, mode(DEFAULT_MODE);"
                , "WS : White+ -> skip;"]

whiteToken :: TypeToken
whiteToken = "WS : (White | '\\n')+ ->  skip;"

doubleAntlrDefinition, integerAntlrDefinition :: TypeToken
integerAntlrDefinition = vcat [ "//Integer predefined token type"
                         , "INTEGER : DIGIT+;"
                         ]
doubleAntlrDefinition =  vcat ["// Double predefined token type"
                            , "DOUBLE : DIGIT+ '.' DIGIT+ ('e' '-'? DIGIT+)?;"
                         ]

stringAntlrDefinition, charAntlrDefinition :: Doc -> (InitToken, AntlrModeDef)
stringAntlrDefinition mode = (stringInitToken, stringModes mode)
charAntlrDefinition mode = (charInitToken, charModes mode)

charInitToken   = "CHAR : '\\''   -> more, mode(CHARMODE);"

stringInitToken = vcat [ "// String token type"
                  , "STRING : '\"' -> more, mode(STRINGMODE);"
                  ]

indentationMode :: AntlrModeDef
indentationMode = vcat [
      "INDENTATION : "
    , "  White*{getText().length() == indentationLength()}?"
    , "  -> mode(INDENT);"
    , "INDENTATION_INCREASED :"
    , "  White*{getText().length() > indentationLength()}?"
    , "  {increaseIndentation(getText());}"
    , "  -> mode(INDENT);"
    , "INDENTATION_DECREASED :"
    , "  White*{getText().length() < indentationLength()}?"
    , "  {decreaseIndentation();}"
    , "  -> mode(INDENT);"
    ]

stringModes, charModes :: Doc -> AntlrModeDef
stringModes modeName = vcat [ "mode STRESCAPE;"
    , "STRESCAPED : Escapable  -> more, popMode ;"
    , "mode STRINGMODE;"
    , "STRINGESC : '\\\\' -> more , pushMode(STRESCAPE);"
    , "STRINGEND : '\"' ->  type(STRING), mode("<>modeName<>");"
    , "STRINGTEXT : ~[\\\"\\\\] -> more;"
    ]

charModes modeName = vcat [ "mode CHARMODE;"
    , "CHARANY     :  ~[\\'\\\\] -> more, mode(CHAREND);"
    , "CHARESC     :  '\\\\'  -> more, pushMode(CHAREND),pushMode(ESCAPE);"
    , "mode ESCAPE;"
    , "ESCAPED : (Escapable | '\\'')  -> more, popMode ;"
    , "mode CHAREND;"
    , "CHARENDC     :  '\\''  -> type(CHAR), mode("<>modeName<>");"
    ]

lexComments :: ([(String, String)], [String]) -> Doc
lexComments ([],[]) = ""
lexComments (m,s) = vcat
    (prod "COMMENT_antlr_builtin" lexSingleComment s ++
         prod "MULTICOMMENT_antlr_builtin" lexMultiComment m )

  where
    prod bg lc ty = [bg, ": ("] ++ punctuate "|" (map lc ty) ++ skiplex
    skiplex       = [") -> skip;"]

-- | Create lexer rule for single-line comments.
--
-- >>> lexSingleComment "--"
-- '--' ~[\r\n]* (('\r'? '\n')|EOF)
--
-- >>> lexSingleComment "\""
-- '"' ~[\r\n]* (('\r'? '\n')|EOF)
lexSingleComment :: String -> Doc
lexSingleComment c =
    "'" <>text (escapeChars c) <>  "' ~[\\r\\n]* (('\\r'? '\\n')|EOF)"

-- | Create lexer rule for multi-lines comments.
--
-- There might be a possible bug here if a language includes 2 multi-line
-- comments. They could possibly start a comment with one character and end it
-- with another. However this seems rare.
--
-- >>> lexMultiComment ("{-", "-}")
-- '{-' (.)*? '-}'
--
-- >>> lexMultiComment ("\"'", "'\"")
-- '"\'' (.)*? '\'"'
lexMultiComment :: (String, String) -> Doc
lexMultiComment (b,e) =
         "'" <> text (escapeChars b)
        <>"' (.)*? '"<> text (escapeChars e)
        <> "'"

javaLexerPreamble =
    vcat [ "@lexer::members"
        , codeblock 2 [
            "public StringBuffer indentation = new StringBuffer();"
            , "private final java.util.Deque<Integer> nestingDiffs = initNestingDiffs();"
            , "private final java.util.Deque<Boolean> ignoringIndentation = initIgnoringIndentation();"
            , "private final java.util.Deque<Token> pendingTokens  = initPendingTokens();"
            , "public void increaseIndentation(String d)"
            , codeblock 2 [ "if(isIgnoringIndentation()) return;"
                    , "int peeking = nestingDiffs.peekFirst();"
                    , "if(peeking == -1) nestingDiffs.push(d.length());"
                    , "else nestingDiffs.push(d.length() - indentationLength());"
                    , "indentation = new StringBuffer(d);"
                ]
            , "public int indentationLength()"
            , codeblock 2 [
                "if (nestingDiffs.peek() == -1) return -1;"
               , "else return indentation.length();"
            ]
            , "public void decreaseIndentation()"
            , codeblock 2 [
                "if(isIgnoringIndentation()) return;"
                , "int popped = nestingDiffs.pop();"
                , "if(popped != -1) indentation = indentation.delete(0, popped);"

            ]
            , "public final java.util.Deque<Integer> initNestingDiffs()"
            , codeblock 2 [
                            "java.util.ArrayDeque<Integer> dq = new java.util.ArrayDeque<Integer>();"
                            , "dq.push(-1);"
                            , "return dq;"
                        ]
            , "public final java.util.Deque<Token> initPendingTokens()"
            , codeblock 2 [
                "java.util.ArrayDeque<Token> dq = new java.util.ArrayDeque<Token>();"
                , "return dq;"
            ]
            , "public final java.util.Deque<Boolean> initIgnoringIndentation()"
            , codeblock 2 [
                "java.util.ArrayDeque<Boolean> dq = new java.util.ArrayDeque<Boolean>();"
                , "dq.push(true);"
                , "return dq;"
            ]
            , "public void ignoreIndentation()"
            , codeblock 2 ["ignoringIndentation.push(true);"]
            , "public void expectIndentation()"
            , codeblock 2 ["ignoringIndentation.push(false);"]
            , "public boolean isIgnoringIndentation()"
            , codeblock 2 ["return ignoringIndentation.peek();"]
            , "public boolean resumeIndentation()"
            , codeblock 2 ["return ignoringIndentation.pop();"]
            , "@Override"
            , "public Token nextToken()"
            , codeblock 2 [ "return getNextToken();"]
            , "private Token getNextToken()"
            , codeblock 2 [ "Token t = null;"
                , "if(pendingTokens.size()>0)"
		, codeblock 2 [ "t = pendingTokens.pop();"]
                , "else"
                , codeblock 2 [ "t = super.nextToken();"
                    , "if(t.getType() == INDENTATION_DECREASED)"
                    , codeblock 2 [
                        "pendingTokens.push(this._factory.create(INDENTATION,indentation.toString()));"
                    ]
                    , "else if (t.getType() == -1)"
                    ,codeblock 2 [
                        "pendingTokens.push(t);"
                        , "pendingTokens.push(t);// twice is better! (Test looks for one more EOF)"
                        , "java.util.Iterator<Integer> it = nestingDiffs.descendingIterator();"
                        , "ignoringBottom:"
                        , codeblock 2 [ "pendingTokens.push(this._factory.create(INDENTATION_DECREASED,\"\"));"
                            , "it.next();"
                        ]
                        , "StringBuffer indVal = new StringBuffer(indentation);"
                        , "int acc = 0;"
                        , "while(it.hasNext())"
                        , codeblock 2 [
                          "acc += it.next();"
                          , "pendingTokens.push(this._factory.create(INDENTATION_DECREASED,indVal.substring(0,acc)));"
                        ]
                        , "t = pendingTokens.pop();"
                    ]
                ]
                , "return t;"
            ]
            , "public final boolean isIndentation(Token t)"
            , codeblock 2 [ "return t.getType() == INDENTATION_DECREASED"
                , "|| t.getType() == INDENTATION"
                , "|| t.getType() == INDENTATION_INCREASED;"
            ]

        ]
    ]

