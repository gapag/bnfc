{-
    BNF Converter: Antlr4 Java 1.8 Generator
    Copyright (C) 2004  Author:  Markus Forsberg, Michael Pellauer,
                                 Bjorn Bringert

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-}

{-
   **************************************************************
    BNF Converter Module

    Description   : This module generates the ANTLR .g4 input file. It
                    follows the same basic structure of CFtoHappy.

    Author        : Gabriele Paganelli (gapag@distruzione.org),


    License       : GPL (GNU General Public License)

    Created       : 15 Oct, 2015

    Modified      :


   **************************************************************
-}
module BNFC.Backend.Java.CFtoAntlr4Parser ( cf2AntlrParse ) where

import Data.List
import BNFC.CF
import BNFC.Backend.Java.Utils
import BNFC.Backend.Common.NamedVariables
import BNFC.Utils ( (+++), (+.+))


-- Type declarations
type Rules       = [(NonTerminal,[(Pattern, Fun, Action)])]
type AtomicPattern = String
type PatternSegment = (Action, AtomicPattern, Action)
type Pattern     = [PatternSegment] -- for each assignment/token, there is a pre- and post- action
type Action      = String
type MetaVar     = (String, Cat)

-- | Creates the ANTLR parser grammar for this CF.
--The environment comes from CFtoAntlr4Lexer
cf2AntlrParse :: TypeMapping -> String -> String -> CF -> SymEnv -> String
cf2AntlrParse tm packageBase packageAbsyn cf env = unlines
    [ header
    , lexerRef
    , tokens
    , prRules packageAbsyn (rulesForAntlr4 tm packageAbsyn cf env)
    ]
  where
    header :: String
    header = unlines
        [ "// -*- Java -*- This ANTLRv4 file was machine-generated by BNFC"
        , "parser grammar" +++ packageBase ++ "Parser;"
        ]
    tokens :: String
    tokens = unlines
        [ "options {"
        , "  tokenVocab = "++packageBase++"Lexer;"
        , "}"
        ]
    lexerRef :: String
    lexerRef = if (hasIndentation cf)
            then javaParserPreamble packageBase
            else ""

rulesForAntlr4 :: TypeMapping -> String -> CF -> SymEnv -> Rules
rulesForAntlr4 tm packageAbsyn cf env = map mkOne getrules
  where
    getrules          = ruleGroups cf
    mkOne (cat,rules) = constructRule tm packageAbsyn cf env rules cat


javaParserPreamble lang = "@parser::members {"++lang++"Lexer ll;}"


-- | For every non-terminal, we construct a set of rules. A rule is a sequence of
-- terminals and non-terminals, and an action to be performed.
constructRule :: TypeMapping
    -> String
    -> CF
    -> SymEnv
    -> [Rule]
    -> NonTerminal
    -> (NonTerminal,[(Pattern, Fun, Action)])
constructRule tm packageAbsyn cf env rules nt =
    (nt, [ (p , funRule r , generateAction tm packageAbsyn nt (funRule r) (revM b m) b)
          | (index ,r0) <- zip [1..(length rules)] rules,
          let isCons = isConsFun (funRule r0)
              (b,r)  = if isCons && elem (valCat r0) revs
                          then (True, revSepListRule r0)
                          else (False, r0)
              (p,m)  = generatePatterns (nonTokenRule (isIndent isCons)) index env r])
 where
   revM False = id
   revM True  = reverse
   revs       = cfgReversibleCats cf
   rul :: Cat -> String
   rul c = firstLowerCase (getRuleName (identCat c))
   nonTokenRule :: (Cat -> (Action, AtomicPattern, Action)) -> Cat -> (Action, AtomicPattern, Action)
   nonTokenRule cs c = if isTokenCat c
                      then noAction $ identCat c
                      else cs c
   isIndent :: Bool -> Cat -> (Action, AtomicPattern, Action)
   isIndent isCons = if hasIndentation cf
                then indFun isCons
                else noAction . rul
   indFun :: Bool -> Cat -> (Action, AtomicPattern, Action)
   indFun isCons c = if (not isCons)&& isList c
                then toggleIndentation (if (isIndentedCat cf (normCatOfList c))
                                        then  IndentationEnterCat c
                                        else  c)
                else noAction $ rul c
   toggleIndentation c = indentationAction (pre c) $ rul c
   pre c = if isIndentationEnter c
            then "expect"
            else "ignore"


noAction :: String -> (Action, AtomicPattern, Action)
noAction s = ("", s , " ")

indentationAction :: String -> AtomicPattern -> (Action, AtomicPattern, Action)
indentationAction pre ap = (brac pre, ap, brac "resume")
    where brac a = "{ll." ++ a ++ "Indentation();}"
-- Generates a string containing the semantic action.
generateAction :: TypeMapping -> String -> NonTerminal -> Fun -> [MetaVar]
               -> Bool   -- ^ Whether the list should be reversed or not.
                         --   Only used if this is a list rule.
               -> Action
generateAction tm packageAbsyn nt f ms rev
    | isNilFun f = "$result = new " ++ c ++ "();"
    | isOneFun f = "$result = new " ++ c ++ "(); $result.addLast("
        ++ p_1 ++ ");"
    | isConsFun f = "$result = " ++ p_2 ++ "; "
                           ++ "$result." ++ add ++ "(" ++ p_1 ++ ");"
    | isCoercion f = "$result = " ++  p_1 ++ ";"
    | isDefinedRule f = "$result = this." ++ f ++ "_"
                        ++ "(" ++ intercalate "," (map resultvalue ms) ++ ");"
    | otherwise = "$result = new " ++ c
                  ++ "(" ++ intercalate "," (map resultvalue ms) ++ ");"
   where

     c                 = packageAbsyn ++ "." ++
                            if isNilFun f || isOneFun f || isConsFun f
                            then identCat (normCat nt) else f
     p_1               = resultvalue $ ms!!0
     p_2               = resultvalue $ ms!!1
     add               = if rev then "addLast" else "addFirst"
     gettext           = "getText()"
     removeQuotes x    = "substring(1, "++ x +.+ gettext +.+ "length()-1)"
     newInstance typ x = "new "++(tm typ [])++"("++x++")"
     charat            = "charAt(1)"
     resultvalue (n,c) = case c of
                          TokenCat "Ident"   -> n'+.+gettext
                          TokenCat "Integer" -> newInstance "Integer" $ n'+.+gettext
                          TokenCat "Char"    -> n'+.+gettext+.+charat
                          TokenCat "Double"  -> newInstance "Double" $ n'+.+gettext
                          TokenCat "String"  -> n'+.+gettext+.+removeQuotes n'
                          _         -> (+.+) n' (if isTokenCat c then gettext else "result")

                          where n' = '$':n


-- | Generate patterns and a set of metavariables indicating
-- where in the pattern the non-terminal
-- >>> generatePatterns CF{cfgPragmas = []} 2 [] (Rule "myfun" (Cat "A") [])
-- (" /* empty */ ",[])
-- >>> generatePatterns CF{cfgPragmas = []} 3 [("def", "_SYMB_1")] (Rule "myfun" (Cat "A") [AnonymousTerminal "def", NonTerminal (Cat "B")])
-- ("_SYMB_1 p_3_2=b ",[("p_3_2",B)])
generatePatterns :: (Cat -> PatternSegment) -> Int -> SymEnv -> Rule -> (Pattern,[MetaVar])
generatePatterns cs ind env r = case rhsRule r of
    []  -> ([noAction " /* empty */ "],[])
    its -> (mkPattern 1 its, metas its)
 where
    mkPattern _ [] = []
    mkPattern n (i:is) = case i of
        NonTerminal c -> (pre, "p_" ++show ind++"_"++ show (n :: Int) ++ "="++ c', post)
            : mkPattern (n+1) is
          where
              (pre,c',post) = case c of
                  TokenCat "Ident"   -> noAction "IDENT"
                  TokenCat "Integer" -> noAction "INTEGER"
                  TokenCat "Char"    -> noAction "CHAR"
                  TokenCat "Double"  -> noAction "DOUBLE"
                  TokenCat "String"  -> noAction "STRING"
                  _                  -> cs c
        AnonymousTerminal s -> case lookup s env of
            (Just x) -> (noAction x):mkPattern (n+1) is
            (Nothing) -> mkPattern n is
        IndentationTerminal s -> (noAction k):mkPattern n is
          where k = case s of
                        "+" -> "INDENTATION_INCREASED"
                        "=" -> "INDENTATION"
                        "-" -> "INDENTATION_DECREASED"
                        _ -> ""
    metas its = [("p_" ++ show ind ++"_"++ show i, category)
                    | (i,NonTerminal category) <- zip [1 :: Int ..] [c | c <- its, countItIn c ]]
    countItIn (IndentationTerminal _) = False
    countItIn _ = True

-- | Puts together the pattern and actions and returns a string containing all
-- the rules.
prRules :: String -> Rules -> String
prRules _ [] = []
prRules packabs ((_, []):rs) = prRules packabs rs
prRules packabs ((nt,(p, fun, a):ls):rs) = -- p is a list of pattern segments
    preamble ++ ";\n" ++ prRules packabs rs
  where
    preamble          = unwords [ nt'
                        , "returns"
                        , "["
                        , packabs+.+normcat
                        , "result"
                        , "]"
                        , ":"
                        , concatMap unrollActions p
                        , "{"
                        , a
                        , "}"
                        , "#"
                        , antlrRuleLabel fun
                        , '\n' : pr ls
                        ]
    alternative (p',fun',a')
                      = unwords ["  |", concatMap unrollActions p', "{", a' , "}", "#"
                        , antlrRuleLabel fun']
    unrollActions (a,b,c) = a++b++c
    catid             = identCat nt
    normcat           = identCat (normCat nt)
    nt'               = getRuleName $ firstLowerCase catid
    pr []             = []
    pr (k:ls) = unlines [alternative k] ++ pr ls
    antlrRuleLabel fnc
      | isNilFun fnc   = catid ++ "_Empty"
      | isOneFun fnc   = catid ++ "_One"
      | isConsFun fnc  = catid ++ "_Cons"
      | isCoercion fnc = "Coercion_" ++ catid
      | otherwise      = getLabelName fnc