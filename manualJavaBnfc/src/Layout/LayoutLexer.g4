// This Antlr4 file was machine-generated by the BNF converter
lexer grammar LayoutLexer;

// *** All this below appears if the grammar is indentation sensitive,m
// e.g. if there is an indentation Something; in the .cf file
@lexer::members {

			public StringBuffer indentation = new StringBuffer();

	    private final java.util.Deque<Integer> nestingDiffs = initNestingDiffs();
	    private final java.util.Deque<Boolean> ignoringIndentation = initIgnoringIndentation();
	    private final java.util.Deque<Token> pendingTokens  = initPendingTokens();

			public void increaseIndentation(String d){
				if(isIgnoringIndentation()) return;
				nestingDiffs.push(d.length() - nestingDiffs.peekFirst());
				indentation.append(d.substring(0,nestingDiffs.peekFirst()));
			}

			public void decreaseIndentation(){
				if(isIgnoringIndentation()) return;
				indentation = indentation.delete(0, nestingDiffs.pop());
			}

			public final java.util.Deque<Integer> initNestingDiffs(){
				java.util.ArrayDeque<Integer> dq = new java.util.ArrayDeque<Integer>();
				dq.push(0);
				return dq;
			}

			public final java.util.Deque<Token> initPendingTokens(){
				java.util.ArrayDeque<Token> dq = new java.util.ArrayDeque<Token>();
				return dq;
			}

			public final java.util.Deque<Boolean> initIgnoringIndentation(){
				java.util.ArrayDeque<Boolean> dq = new java.util.ArrayDeque<Boolean>();
				dq.push(false);
				return dq;
			}

			public void ignoreIndentation(){
				ignoringIndentation.push(true);
			}

			public void expectIndentation(){
				ignoringIndentation.push(false);
			}

			public boolean isIgnoringIndentation(){
				return ignoringIndentation.peek();
			}

			public boolean resumeIndentation(){
				return ignoringIndentation.pop();
			}

	    @Override
			public Token nextToken() {
					if(isIgnoringIndentation()){
						return getNextTokenIgnoringIndentation();
					}
					else{
						return getNextToken();
					}
			}

			private Token getNextToken(){
				if(pendingTokens.size()>0){
					return pendingTokens.pop();
				}else{
					Token t = super.nextToken();
					if(t.getType() == INDENTATION_DECREASED){
						pendingTokens.add(this._factory.create(INDENTATION,indentation.toString()));
					}
					return t;
				}
			}

			private Token getNextTokenIgnoringIndentation(){
				Token t = null;
				do{
					t = getNextToken();
				}while(isIndentation(t));
				return t;
			}

			private final boolean isIndentation(Token t){
			  return t.getType() == INDENTATION_DECREASED
			  			|| t.getType() == INDENTATION
			  			|| t.getType() == INDENTATION_INCREASED;
			}

}
// *** Above is conditional to the presence of indentation pragmas! ^
// Predefined regular expressions in BNFC
fragment LETTER  : CAPITAL | SMALL ;
fragment CAPITAL : [A-Z\u00C0-\u00D6\u00D8-\u00DE] ;
fragment SMALL   : [a-z\u00DF-\u00F6\u00F8-\u00FF] ;
fragment DIGIT   : [0-9] ;

// Identifier token type
fragment
IDENTIFIER_FIRST : LETTER | '_';
// *** This needs to be restructured if indentation matters
fragment
White : (' ' | '\r' | '\t' );
// Escapable sequences
fragment
Escapable : ('"' | '\\' | 'n' | 't' | 'r');

// *** Indentation specific tokens!
INDENTATION : White*{getText().length() == indentation.length()}? -> mode(INDENT);
INDENTATION_INCREASED : White*{getText().length() > indentation.length()}?
	{increaseIndentation(getText());}
  -> mode(INDENT);
INDENTATION_DECREASED : White*{getText().length() < indentation.length()}?
	{decreaseIndentation();}
  -> mode(INDENT);
// *** Above, indentation specific tokens ^
mode INDENT; // What before was standard mode now gets translated below.
Surrogate_id_SYMB_0 : '=' ;
Surrogate_id_SYMB_1 : ':' ;
Surrogate_id_SYMB_2 : 'True' ;
Surrogate_id_SYMB_3 : 'if' ;
Surrogate_id_SYMB_4 : ',' ;

IDENT : IDENTIFIER_FIRST (IDENTIFIER_FIRST | DIGIT)* ;

// *** Newline item comes from handling of whitespace for indentation
NEWLINE : 'r'? '\n'  -> skip, mode(DEFAULT_MODE);
WS : White+ -> skip;
// *** Above, indentation dependent fragment ^

ErrorToken : . ;